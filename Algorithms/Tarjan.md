## Tarjan

#### 算法思想

一个强连通分量（SCC）中的所有节点，必然构成一颗搜索树中的子树。

所以找强连通分量，就变成了找 SCC 的根

#### 算法步骤

DFN[i] 表示 i 这个节点搜索到的时间戳

LOW[i] 表示 i 这个节点以及他的子树的最小时间戳

vis[i] 表示 i 这个节点是否在栈中

stack 按照搜索顺序，把已经遍历到的点入栈了

COLOR[i] 表示 i 这个节点的颜色

sz[i] 表示 i 这个颜色有多少个节点

1. 遍历所有节点
   1. 放入栈中
   2. vis 标记
   3. DFN 标记
   4. LOW 初始化为自己
2. 遍历所有能搜到的点
   1. 如果这个点的 DFN 为 0
      1. 搜索他，并更新 LOW 数组
   2. 如果这个点的DFN不为0，那么判断一下这个点是否在栈中，在的话，更新 LOW
      1. 因为说明当前点 pos，有一条连向自己搜索树的父亲的边
      2. 更新的时候需要注意，是和 DFN[to] 去比，而不是 LOW[to]，因为 这个 to 可以被 pos
3. 如果搜完了全部点，判断一下 LOW[pos] == DFN[pos]，如果相等，说明 pos 这个点是 SCC 的根